---
layout: post
title: 쓰레드
categories: lang
tags: java
---

## <span style="color:gray">들어가기 앞서.</span>

---

#### <span style="background-color:black; color:white">이미지 업로드시 속도 문제와 만나다.</span>

기존의 이미지 업로드의 경우 아래와 같이 작동한다.

> 이미지 업로드 클릭 → 썸네일 생성 + 이미지 업로드 (이미지 갯수만큼 반복)

그러나 여기에는 치명적인 단점이 있었다. 용량이 큰 이미지 파일의 갯수가 30개, 40개 혹은 

그 이상일 경우에는 업로드 속도가 눈에 띄게 느려졌기 때문이다. 

<br>

처음에는 for문으로 뭔가를 해보려고 했지만, 근본적인 문제가 해결되지는 않았다.

그러다가 <span style="color:red">썸네일을 뭔가 백그라운드에서 만들면 좋을거 같은데...🤔</span> 라는 생각이 들어

구글 검색창에다가 `자바에서 백그라운드로 작업하기` 라는 검색어로 구글링을 하다가

**<span style="background-color:#F0E68C">쓰레드</span>** 에 대해서 알게되었다.

<br>

#### <span style="background-color:black; color:white">업로드 속도를 개선해보자!!</span>

쓰레드 사용하여 개선된 코드의 동작방식은 아래와 같다.

> 이미지 업로드 클릭 →  이미지 업로드 (썸네일 생성은 서브쓰레드가 수행)

`join()` 메서드를 사용하지 않으면, 메인 쓰레드는 서브 쓰레드가 일을 마칠 때 까지 기다리지 않기 

때문에 사용자 입장에서 보다 빠르게 이미지 업로드를 할 수 있다. 물론 서브쓰레드가 끝나기 전 까지 

썸네일 이미지는 보이지는 않지만, 이미지는 정상적으로 업로드가 되는걸 확인할 수 있었다. 

<img src = "/assets/img/java/thread/정상작동.png"><br>

이제 쓰레드를 좀 더 자세히 공부해자!! https://honbabzone.com/java/java-thread/#step-3--thread-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84

<br>

## <span style="color:gray">쓰레드</span>

> 쓰레드는 OS에 종속적이다. 스케쥴러가 쓰레드의 순서를 결정한다.

---

#### <span style="background-color:black; color:white">프로세스와 쓰레드</span>

▷ `프로세스 : 쓰레드 = 공장 : 일꾼`

하나의 새로운 프로세스를 생성하는 것보다, 하나의 새로운 쓰레드를 생성하는 것이

더 적은 비용이 든다. **프로세스**는 실행 중인 프로그램, 자원과 쓰레드로 구성되고

**쓰레드**는 프로세스 내에서 실제 작업을 수행한다. 모든 프로세스는 최소한 하나의 

쓰레드를 가지고 있다.

<br>

#### <span style="background-color:black; color:white">멀티쓰레드의 장단점</span>

> 멀티쓰레드 자체는 어렵지 않지만, 멀티쓰레드가 효율적으로 돌아가게 하는게 어렵다.

**<u>장점</u>**

• 시스템 자원을 보다 효율적으로 사용할 수 있다.

• 사용자에 대한 `응답성(responseness)`이 향상된다.

• 작업이 분리되어 코드가 간결해 진다.

<br>

**<u>단점</u>**

• `동기화(Synchronization)`에 주의해야 한다.

• `교착상태(Dead-lock)`가 발생하지 않도록 주의해야 한다.

• `기아현상`이 발생하지 않도록 주의해야 한다. (특정 쓰레드가 작업할 기회가 없는것.)

• 각 쓰레드가 효율적으로 고르게 실행될 수 있게 해야 한다.

<br>

## <span style="color:gray">쓰레드의 구현과 실행</span>

---

아래의 두 방법 모두 `run()` 메소드를 구현해주면 된다.

#### <span style="background-color:black; color:white">Thread클래스를 상속</span>

**<u>구현</u>**

```java
class MyThread extends Thread {
    public void run() {
        /* 작업 내용 */
    };
}
```

**<u>실행</u>**

```java
MyThread t1 = new MyThread();       // 쓰레드 생성
t1.start();                         // 쓰레드 실행
```

<br>

#### <span style="background-color:black; color:white">Runnable 인터페이스를 구현</span>

**<u>구현</u>**

```java
public interface Runnable {
    public abstract void run();
}
```
```java
class MyThread implements Runnable {
    public void run() {
        /* 작업 내용 */
    };
}
```

**<u>실행</u>**

```java
Runnable r = new MyThread();
Thread t2 = new Thread(r);      // Runable을 매개변수로 같는 Thread생성자.
t2.start();                     // 쓰레드 실행
```

<br>

#### <span style="background-color:black; color:white">start와 run</span>

`start()` 메소드를 호출해야 새로운 스택(S1)이 생기고, S1에 `run()` 메소드가 쌓인다. 

<br>

## <span style="color:gray">싱글쓰레드와 멀티쓰레드</span>

---

#### <span style="background-color:black; color:white">작업시간</span>

멀티쓰레드가 싱글쓰레드 보다 작업시간이 더 소요되는데, 그 이유는 OS 스케쥴러에 의해

번갈아가면서 쓰레드가 작업을 한다. 

이때 작업하는 쓰레드가 바뀔 때 **<span style="background-color:yellow">문맥교환(Context Switching)</span>** 이 일어나기 때문이다.

<br>

## <span style="color:gray">쓰레드의 I/O Blocking</span>

---

#### <span style="background-color:black; color:white">I/O Blocking</span>

싱글쓰레드의 경우에 외부 장치의 입출력이 있는 경우에, 값을 넣을 때 동안 기다리는

구간이 발생한다. 이 때 blocking이 걸리게 되므로 뒤에 있는 작업도 대기 상태가 된다.

반면에 멀티쓰레드 환경에서는 main 쓰레드가 blocking에 걸려도 나머지 쓰레드는 본인의

일을 수행한다. 이렇게 되면 보다 자원을 효율적으로 사용할 수 있다. 