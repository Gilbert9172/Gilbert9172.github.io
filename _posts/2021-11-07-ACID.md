---
layout: post
title: Transaction
categories: db
---

### 💡 ***Transaction 이란?***

▪ DB의상태를 변화시키기 위해서 수행하는 작업의 단위

▪ 더 이상 쪼갤 수 없는 업무 처리의 최소 단위

▪ 메모리의 모든 변화를 하나의 작업 단위로 묶는다. 하나라도 실패하면 전체가 실패

▪ 성공 혹은 실패 두개의 결과만 존재.

<br>

예를 들면, A가 B에게 10000원을 이체했다. 하지만 와이파이 연결의 문제로 이체를 실패했다.

이럴 경우 B의 통장에 10000원이 이체되지 않았기 때문에, 이체가 성립되지 않는다.

이 처럼 A가 돈을 이체하는 행위와 B가 돈을 받는 행위는 별개로 분리 될 수 없다.

다시말해, 위와 같은 케이스는 하나의 거래내역으로 처리되어야 하는 단일 거래이다.

이런 거래의 최소 단위를  <span style="color:#4169E1">**트랜잭션**</span> 이라고 한다. 트랜잭션이 완료 되었을 경우만, 

commit을 하고, 문제가 발행했을 때는 롤백(다시 A의 계좌에 10000원이 들어간다.)을 한다.

---

<br>

### 💡 ***Transaction의 성질 - ACID***

#### 1. Atomicity (원자성)

하나의 트렌잭션 내의 모든 명령은 전부 성공해야 한다. → 부분적으로 실행되면 안되는 성질

어느 <span style="color:#4169E1">**하나라도 정상적으로 작동하지 않으면, 트랜잭션은 실패**</span>한다. 

위의 예시에서도 알 수 있듯이, 이체가 실패하면 실패로 돌아가야한다는 것이 Atomicity이다. 

SQL에서도 마찬가지이다. 

특정 query(질의문)를 실행할 때 실패하는 부분이 있다면 전부 실패한다.

<br>

#### 2. Consistency (일관성)

트랜잭션이 성공적으로 이루어지면, 언제나 일관성 있는 데이터베이스 상태로 변환되어야 

한다. 즉, <span style="color:#4169E1">**데이터베이스의 제약이나 규칙에 의거한 데이터베이스여야 한다는 뜻**</span>이다.

예를 들어 "각 고객들은 이름이 있어야한다" 라는 제약이 원래 DB에 있다고 하면,

- Case 1 : 이름 없는 새로운 고객을 추가하는 쿼리
- Case 2 : 기존 고객의 이름을 삭제하는 쿼리 

위의 트랜잭션들은 "각 고객들은 이름이 있어야한다"라는 본래 DB의 제약을 위배한다.

이런 트랜잭션 이후에 데이터베이스의 상태는 일관되지 않아진다. 

<br>

Movie와 Video 테이블이 있을 때 Video 테이블의 기본 키(primary key)인 movie_id가 

외래키로 존재한다고 가정해봤다. 만약 movie_id의 제약 조건이 Movie 테이블에서 변경되면, 

Video 테이블에서도 movie_id가 변경되어야 한다.

<br>

#### 3. Isolation (고립성)

하나의 트렌잭션이 다른 트랜잭션과 독립되어야 한다는 특성이다. 

즉, <span style="color:#4169E1">**트랜잭션끼리 서로 간섭할 수 없다.**</span> 

또한 수행중인 트랜잭션이 완전히 완료될 때까지 다른 트랜잭션의 수행결과를 참조할 수 없다.

쉽게 말해 각 트랜잭션은 시스템 내에세 동시에 수행되고 있는 다른 트랜잭션들을 알 수 없다.

<br>

예를 들어, 나의 통장 잔고는 10000원이다. 근데 친구A 에게 7000원씩 보내줘야한고 해보자.

친구 A에게 7000원을 보내던 도중, 교통비 10000원이 결제 될 수 있을까? 절대 불가하다. 

이게 고립성의 효과인 것 같다. 

잔고가 10000원인 통장에서 "7000원 송금"과 "10000원 출금"은 동시에 일어나선 안된다.

7000원 송금이 이뤄지고 교통비는 미납이 될 것이다.

이렇게 각 행위들은 서로 간섭할 수 없고, 서로 어떤 연산을 하는지도 알 수 없다.

<br>

#### 4. Durability (지속성)

<span style="color:#4169E1">**하나의 트랜잭션이 성공적으로 수행되었다면**</span> 해당 트랜잭션에 대한 로그(기록)가 남고,

'런타임 오류'나 '시스템 오류'가 발생하더라도 <span style="color:#4169E1">**해당 기록은 영구적이어야 한다는 특성**</span>이다.

<br>

예를 들어, 친구에게 10000원을 이체 했는데, 해당 은행 어플에 오류가 발생해 어플이 종료가 

됐다고 가정해봤다. 만약 "트랜잭션 로그(이체내역)"가 남지 않는 다면 나의 10000원은 

어디로 갔는지 절대 알수가 없다. 

이런 불상사를 방지하기 위해서 모든 트랜잭션은 로그로 남겨져 `시스템 장애 발생 전 상태`로 

되돌릴 수 있어야 한다. 또한 모든 트랜잭션은 로그에 모든 것이 저장된 후에만 정상적으로 

처리된 "commit 상태" 로 고려될 수 있다.

---

<br>

### 💡 ***Transaction 연산***

#### 1. Commit

Commit 연산은 모든 작업들을 정상적으로 처리하겠다고 확정하는 명령어로서, 처리과정을

DB에 영구히 저장하는 것을 말한다. 즉, 하나의 트랜잭션 과정을 종료하는 것이다.

그리고 Commit을 수행하면 이전 데이터가 완전히 업데이트된다.

<br>

#### 2. Rollback

작업 중 문제가 발생하여 트랜잭션의 처리과정에서 발생한 변경사항을 취소하는 명령이다.

해당 트랜잭션의 일부가 정상적으로 처리됐다 하더라도, 트랜잭션의 원자성을 구현하기 

위해 해당 트랜잭션이 행한 모든 연산을 취소한다는 특징을 가지고 있다.

해당 연산은 트랜잭션이 시작되기 이전의 상태로 되돌린다. 

즉, 마지막 Commit을 완료한 시점으로 다시 돌아간다. Commit하여 저장한 것만 복구한다.

Rollback시에는 해당 트랜잭션을 재시작하거나 폐기한다.

<br>

#### 3. Save Point

임시저장 또는 부분저장과 같은 맥락으로 이해할 수 있다. 보통 롤백을 명시하면 

삽입,삭제,업데이트 등의 작업 전체가 취소되는데, save point는 전체가 아닌 특정 부분에서

트랜잭션을 취소하기 위해 사용한다. save point를 쓰면 현재의 트랜잭션을 작게 분할하는 

것이 가능하다. Save point는 여러 개의 SQL문의 실행을 수행하는 트랜잭션의 경우에 

사용자가 트랜잭션 중간 단계에서 save point를 지정할 수 있다. 

Save point를 사용하려면 취소하려는 지점을 명시한 뒤, 그 지점까지 작업을 취소하는 식으로

사용하는데 이 지점을 save point라고 한다.

save point를 지정한 뒤 `rollback to save point name`을 실행하면 해당 save point 

지점까지 처리한 직업이 롤백된다.

---

<br>

### 💡 ***Transaction 상태***

Active (활동) : 트랜잭션이 실행중인 상태.

Failed (실패) : 트랜잭션 실행에 오류가 발생하여 중단된 상태.

Aborted (철회) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태.

Partially Committed (부분완료) : Commit 연산이 실행되기 직전의 상태

Committed (완료) : Commit 연산을 실행한 후의 상태

---