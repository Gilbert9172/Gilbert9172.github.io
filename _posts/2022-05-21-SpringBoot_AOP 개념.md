---
layout: post
title: 스프링 AOP개념
categories: spring
tags: aop
---

## <span style="color:gray">[ 핵심기능과 부가기능 ]</span>

**핵심기능**은 해당 객체가 제공하는 고유의 기능이다.

**부가기능**은 핵심기능을 보조하기 위해 제공되는 기능이다.

그리고 보통은 아래의 그림 처럼 부가기능과 핵심기능이 섞여서 들어간다.

<img src="/assets/img/spring/aop/aop1.png">

<br>

보통 부가 기능은 여러 클래스에 걸쳐서 함께 사용된다. 

예를 들어서 모든 애플리케이션 호출을 로깅 해야 하는 요구사항을 생각해보자. 

이러한 부가 기능은 **`횡단 관심사(cross-cutting concerns)`** 가 된다. 

쉽게 이야기해서 **<span style="background-color:yellow">하나의 부가 기능이 여러 곳에 동일하게 사용된다는 뜻이다.</span>**

<br>

#### 부가 기능 적용의 문제 

**✓ 부가 기능을 적용할 때 아주 많은 반복이 필요하다.**

**✓ 부가 기능이 여러 곳에 퍼져서 중복 코드를 만들어낸다.**

**✓ 부가 기능을 변경할 때 중복 때문에 많은 수정이 필요하다.**

**✓ 부가 기능의 적용 대상을 변경할 때 많은 수정이 필요하다.**

<br>

소프트웨어 개발자에서 변경 지점은 하나가 될 수 있도록 모듈화 되어야 한다.

그런데 부가 기능처럼 특정 로직을 애플리케이션 전반에 적용하는 문제는 일반적인 OOP 방식으로 해결이 어렵다.

---

<br>

## <span style="color:gray">[ Aspect ]</span>

선배 개발자들은 부가 기능을 핵심 기능에서 분리하고 한 곳에서 관리하도록 했다. 

그리고 해당 부가 기능을 어디에 적용할지 선택하는 기능도 만들었다. 

이렇게 부가 기능과 부가 기능을 어디에 적용할지 선택하는 기능을 합해서 하나의 모듈로 만들었는데 

이것이 바로 <span style="background-color:yellow">Aspect</span>다. 

<br>

Aspect는 쉽게 이야기해서 부가 기능과, 해당 부가 기능을 어디에 적용할지 정의한 것이다. 

예를 들어서 로그 출력 기능을 모든 컨트롤러에 적용해라 라는 것이 정의되어 있다.

그리고 스프링이 제공하는 **`어드바이저`** 도 ***어드바이스(부가 기능)와 포인트컷(적용대상)*** 을

가지고 있어서 개념상 하나의 에스펙트이다.

<br>

Aspect는 우리말로 해석하면 관점이라는 뜻인데, 이름 그대로 애플리케이션을 바라보는 관점을 

하나하나의 기능에서 **`횡단 관심사(Cross-sutting concerns)관점`** 으로 달리 보는 것이다.

참고로 AOP는 OOP를 대체하기 위한 것이 아니라 횡단 관심사를 깔끔하게 처리하기 어려운 OOP의 

부족한 부분을 보조하는 목적으로 개발되었다.

---

<br>

## <span style="color:gray">[ AOP 적용방식 ]</span>

크게 3가지 방법이 있다.

**✓ 컴파일 시점** 

실제 대상 코드에 애스팩트를 통한 부가 기능 호출 코드가 포함된다. AspectJ를 직접 사용해야 한다.

<br>

**✓ 클래스 로딩 시점**

실제 대상 코드에 애스팩트를 통한 부가 기능 호출 코드가 포함된다. AspectJ를 직접 사용해야 한다.

<br>

**✓ 런타임 시점**

실제 대상 코드는 그대로 유지된다. 대신에 프록시를 통해 부가 기능이 적용된다. 

따라서 항상 프록시를 통해야 부가 기능을 사용할 수 있다. **<span style="background-color:yellow">스프링 AOP는 이 방식을 사용한다.</span>**

<br>

## <span style="color:gray">[ AOP 적용 위치 ]</span>

AOP는 메서드 실행 위치 뿐만 아니라 다음과 같은 다양한 위치에 적용할 수 있다. 


|적용 가능 지점(조인 포인트)|
|---------------------------|
|생성자|
|필드 값 접근|
|static 메서드 접근|
|메서드 실행|

<br>

이렇게 AOP를 적용할 수 있는 지점을 **`조인 포인트(Join point)`** 라 한다.

AspectJ를 사용해서 컴파일 시점과 클래스 로딩 시점에 적용하는 AOP는 

바이트코드를 실제 조작하기 때문에 해당 기능을 모든 지점에 다 적용할 수 있다.

프록시 방식을 사용하는 스프링 AOP는 ***<span style="background-color:yellow">메서드 실행 지점에만</span>*** AOP를 적용할 수 있다.

프록시는 메서드 오버라이딩 개념으로 동작한다. 

따라서 생성자나 static 메서드, 필드 값 접근에는 프록시 개념이 적용될 수 없다.

즉, ***<span style="background-color:yellow">프록시를 사용하는 스프링 AOP의 경우에 조인 포인트는 메서드 실행으로 제한되고,</span>***

***<span style="background-color:yellow">스프링 컨테이너가 관리할 수 있는 스프링 빈에만 AOP를 적용할 수 있다.</span>***

<br>

> 참고

스프링은 AspectJ의 문법을 차용하고 프록시 방식의 AOP를 적용한다. 

AspectJ를 직접 사용하는 것이 아니다.

<br>

> 중요!!!

스프링이 제공하는 AOP는 프록시를 사용한다. 따라서 프록시를 통해 메서드를 실행하는 시점에만 AOP가 적용된다. 

AspectJ를 사용하면 더 복잡하고 다양한 기능을 사용할 수 있는데 왜 스프링부트는 그런 기능을 사용하지 않는걸까? 

사실 AspectJ를 사용하려면 공부할 내용도 많고, 자바 관련 설정도 복잡하다. 

반면에 스프링 AOP는 별도의 추가 자바 설정 없이 스프링만 있으면 편리하게 AOP를 사용할 수 있다.

실무에서는 스프링이 제공하는 AOP 기능만 사용해도 대부분의 문제를 해결할 수 있다.

---

<br>

## <span style="color:gray">[ AOP 용어 정리 ]</span>

<br>

#### ⒈ JOIN POINT

✓ 어드바이스가 적용될 수 있는 위치, 메소드 실행, 생성자 호출, 필드 값 접근, static 메서드 접근 같은 프로그램 실행 중 지점

✓ 조인 포인트는 추상적인 개념이다. ***<span style="background-color:yellow">AOP를 적용할 수 있는 모든 지점이라 생각하면 된다.</span>***

✓ 스프링 AOP는 프록시 방식을 사용하므로 조인 포인트는 항상 메소드 실행 지점으로 제한된다.

<br>

#### 포인트컷(Pointcut)

✓ `조인 포인트` 중에서 어드바이스가 적용될 위치를 선별하는 기능

✓ 주로 AspectJ 표현식을 사용해서 지정

✓ 프록시를 사용하는 스프링 AOP는 메서드 실행 지점만 포인트컷으로 선별 가능

<br>

#### 타켓(Target)
어드바이스를 받는 객체, 포인트컷으로 결정

<br>

#### 어드바이스(Advice) 
부가 기능

특정 조인 포인트에서 Aspect에 의해 취해지는 조치

Around(주변), Before(전), After(후)와 같은 다양한 종류의 어드바이스가 있음

<br>

#### 애스펙트(Aspect)

어드바이스 + 포인트컷을 모듈화 한 것 @Aspect 를 생각하면 됨

여러 어드바이스와 포인트 컷이 함께 존재

<br>

#### 어드바이저(Advisor)

하나의 어드바이스와 하나의 포인트 컷으로 구성 

스프링 AOP에서만 사용되는 특별한 용어

<br>

#### 위빙(Weaving)
포인트컷으로 결정한 타켓의 조인 포인트에 어드바이스를 적용하는 것 

위빙을 통해 핵심 기능 코드에 영향을 주지 않고 부가 기능을 추가 할 수 있음 

AOP 적용을 위해 애스펙트를 객체에 연결한 상태
    컴파일 타임(AspectJ compiler)
    로드 타임
    런타임, 스프링 AOP는 런타임, 프록시 방식

<br>

#### AOP 프록시
AOP 기능을 구현하기 위해 만든 프록시 객체, 스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시이다.

---