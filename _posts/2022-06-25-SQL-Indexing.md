---
layout: post
title: Indexing
categories: sql
---

## <span style="color:gray">테이블을 읽는 방식</span>

DB에서 테이블을 읽어들이는 방식은 크게 Full-Scan, Range-Scan 으로 나뉜다.

***<span style="color:#4682B4">Full-Scan 은 테이블에 포함된 모든 레코드를 처음부터 끝까지 읽는 방식이고</span>*** 

**<span style="color:#008B8B">Range-Scan 은 테이블의 일부 레코드에만 접근하는 방식이다.</span>** 이 두 가지 방식 중에

Range-Scan을 할 때 ***`Index`*** 를 이용하면 성능을 향상시키는데 도움이 된다.

---

<br>

## <span style="color:gray">Index</span>

***<span style="background-color:yellow"> Index는 RDBMS에서 검색 속도를 높이기 위한 기술이다.</span>***

TABLE의 컬럼을 색인화하여 검색시 해당 테이블의 레코드를 Full Scan하지 않고, 색인화 되어있는 

INDEX를 검색하여 검색 속도를 빠르게 한다. 보통 SELECT 쿼리의 WHERE절이나 JOIN을 사용했을 떄 

INDEX가 사용되며, SELECT 쿼리의 속도를 빠르게 하느데 목적을 두고 있다.

따라서 DELETE, INSERT, UPDATE 쿼리에는 해당 사앙이 없으면 Index 사용시 오히려 느려진다.

조금더 자세히 알아보면, SQL서버에서 데이터의 레코드는 내부적으로 아무런 순서없이 저장된다.

이때 데이터 저장 영역을 **`Heap 영역`** 이라고 한다. Heap 영역에서는 인덱스가 없는 테이블의

데이터를 찾을 때 전체 데이터 페이지의 처음 레코드부터 끝 페이지의 마지막 레코드까지 모두

조회하여 검색조건과 비교하게 된다. 이러한 데이터 검색방법을 위에 설명한 Full-Scan이라 한다.

---

<br>

## <span style="color:gray">Index 사용 이유</span>

⒈ WHERE절과 일치하는 열을 빨리 찾기 위해.

⒉ Join을 실행할 때 다른 테이블에서 열을 추출하기 위해.

⒊ 특정하게 인덱스된 컬럼을 위한 `MIN()` 또는 `MAX()` 값을 찾기 위해.

---

<br>

## <span style="color:gray">Index 알고리즘</span>

#### 들어가기에 앞서...

우선 들어가기에 앞서 이진트리에 대해서 알아야한다.

이진트리는 각각의 노드가 최대 두 개의 자식 노드를 가지는 트리 자료구조이다.

이진트리에는 정이진트리, 완전이진트리, 균형이진트리 등이 있다. 

|종류|설명|
|----|----|
|정이진트리|리프노드가 끝까지 정말 꽉 찬 트리|
|완전이진트리|마지막 레벨을 제외한 모든 레벨에서 순서대로 노드가 꽉 채워진 트리|
|균형이진트리|리프노드의 레벨차이가 최대 1레벨 까지만 나는 트리(균형을 유지)|

균형이진트리는 검색할 때 최악의 경우에도 O(logN)의 안정성을 유지한다.

그리고 균형이진트리는 AVL트리, 레드블랙트리,B-Tree, B+Tree 등에서 주로 사용된다.

```txt
여기서 잠깐!!! 시간 복잡도 O(logN)이 나오는 이유!!!

예를 들어 2개의 자식 노드를 가지는 이진트리를 이용해서 M개의 노드 중 원하는 값의 

노드를 찾는다고 가정을 해보자. 처음에는 M개의 노드 모두 탐색 대상이지만, 

루트 노드에서 첫번째 자식 노드 층으로 이동하게 되면 탐색해야 할 대상의 수가 M/2개가 된다. 

그리고 순차적으로 검색해야할 대상의 수는 [M/2 개 => M/4 개 => M/8 개 => ...] 가 될 것이다.

만약 탐색을 해야하는 자료의 수가 2^n개라면, 이진 트리를 사용할 경우 n번의 탐색을 통해서 

원하는 값을 찾을 수 있게 된다. 이를 일반화하면 각 노드의 자식노드가 M개인 트리에서 

N개의 자료 중 원하는 자료를 탐색하는 알고리즘의 시간 복잡도는 [밑이 M인 logN] 이 된다.
```

<br>

#### B-Tree

DB는 Index 자료구조로 이 B-Tree를 사용한다. 균형트리 중 B-Tree를 사용하는 이유는 

B-Tree는 하나의 노드에 여러 개의 데이터 요소를 저장할 수 있는 점과 데이터 탐색뿐 아니라 

저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가지기 때문이다. 또 항상 정렬된 상태를

유지하고 있고 참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능하다는 

장점도 가지고 있다. B-Tree의 특징은 아래와 같다.

|특징|
|----|
|각 녿의 자료는 정렬되어 있다.|
|자료는 중복되지 않는다.|
|모든 리프노드는 같은 레벨에 있다.|
|루트노드는 자신이 리프노가 되지 않는 이상 적어도 2개 이상의 자식을 가진다.|
|루트노드가 아닌 노드들은 적어도 M/2개의 자식 노드를 가지고 있다. (최대M개)|

<br>

#### B+Tree

Index에 일반적으로 사용되는 알고리즘은 B+ Tree 알고리즘이다

B+Tree는 B-Tree의 데이터의 순차접근 문제를 개선하기 위해 제시되었다. B-Tree에서는 중복값 없이 

한 개의 노드에만 key가 유일하게 존재했으나, B+Tree는 리프노드와 그 리프노드의 부모 노드에서 

공존할 수 있다. B+Tree의 `리프 노드`는 연결리스트로 구성되어 있으며 `순차 집합(Sequence Set)`

이라고 하면 오름차순으로 정렬이 되어 있다. 여기에 데이터가 담기는 것이다. 


리프 노드가 아닌 `비단말 노드`는 `인덱스 집합(Index Set)`이라고 부르며 데이터로의 빠른 접근을

위한 인덱스 역할만 하기 때문에 키와 포인터로만 구성된다. 

> 리프노드 : 자식이 없는 노드.(단말노드, 말단노드, 잎노드)

> 비단말 노드 : 적어도 하나 이상의 자식을 가지는 노드

따라서 B+Tree는 ***<span style="background-color:yellow">기존의 B-Tree 구조에 데이터의 연결 리스트로 구현된 색인구조라고 할 수 있다.</span>***

이 때문에 순차적인 탐색에 매우 유리하다. 오늘날 DB에서 가장 중요한 것은 검색속도이기 때문에

주로 DB에서 B+Tree를 사용하는 이유이기도 하다.

|특징|
|----|
|데이터노드(Sequence Set)의 자료는 정렬되어 있다.|
|데이터노드(Sequence Set)에서는 데이터가 중복되지 않는다.|
|모든 리프노드는 같은 레벨에 있다.|
|리프노드가 아닌 노드의 키값의 수는 그 노드의 서 브트리수 보다 하나가 적다.|
|모든 리프노드는 연결리스트로 연결되어 있다.|



📚 [B+Tree 실습](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

---

<br>

## <span style="color:gray">참고한 사이트 및 블로그</span>

##### 인덱스 관련 블로그
***📚 [옛날에 정리해둔 내용_내블로그](https://gilbert9172.github.io/db/2021/12/27/index/)***
***📚 [velog.io/@gillog](https://velog.io/@gillog/SQL-Index%EC%9D%B8%EB%8D%B1%EC%8A%A4)***

<br>

##### 자료구조 관련 블로그

***📚 [ssocoit.tistory](https://ssocoit.tistory.com/217)***
***📚 [8iggy.tistory](https://8iggy.tistory.com/191)***
***📚 [gmlwjd9405.github.io](https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html)***
***📚 [ookyungmin.github.io](https://kookyungmin.github.io/study/2018/07/29/data_structure_02/)***

---